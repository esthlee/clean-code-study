# 13장 동시성 

## 동시성이 필요한 이유?
- 즉, 한 프로그램에서 여러 개의 작업을 "겉보기에는 동시에" 실행하는 것.
- 여러 작업을 "겹쳐서" 실행하는 것.
- 응답시간과 작업 처리량 개선에도 효과적.
- 하지만, 동시성은 구현하기 어렵다.
  
## 난관
- **동시성은 다소 부하를 유발한다.** 성능면에서 부하가 걸리며, 코드도 더 짜야한다.
- **동시성은 복잡하다.** 간단한 문제라도 복잡하다.
- **일반적으로 버그는 재현하기 어렵다.** 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무식하기 쉽다.
- **동시성을 구현하려면, 근본적인 설계 전략을 재고해야한다.**
  
## 동시성 방어 원칙
- 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙
  
1. 단일 책임 원칙
- 동시성 관련 코드는 다른 코드와 분리 해야한다.
  
2. 따름 정리: 자료 범위를 제한하라
- 프로세스: 프로그램 실행 인스턴스 (크롬 브라우저)
- 스레드 : 그 안에서 동시에 실행할 있는 작은 작업 단위, 스레드 여러개: 동시 처리 가능 (탭 여러개) 
- 공유 객체: 여러 스레드가 같이 사용하는 데이터 (공용 리스트, 숫자)
- 임계 영역: 동시에 접근하면 안되는 중요한 코드 부분
- synchronized 키워드 : 한 번에 한 스레드만 임계영역에 들어가게 막는 키워드
- 공유 객체를 사용하는 코드 내 임계영역을 synchroniczed 키워드로 보호라도록 권장한다. (헌 번에 한 스레드만 그 코드에 들어가게 막는 것)

```python
import threading

counter = 0  # 공유 변수

def increment():
    global counter
    for _ in range(100000):
        counter += 1  # 여러 스레드가 동시에 접근하면 문제 발생

threads = [threading.Thread(target=increment) for _ in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()

print(f"최종 counter 값: {counter}")  # 예상: 500000, 실제: 실행할 때마다 다름
```
- **자료를 캡슐화하라, 공유 자료를 최대한 줄여라**.
  
3. 따름 정리: 자료 사본을 사용하라
- 공유 자료를 줄이려면, 처음부터 공유하지 않는 방법이 가장 좋다.
- 코드가 문제를 일으킬 가능성도 낮아진다.

4. 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현한다. (다른 스레드와 자료를 공유x)
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- 독자적인 스레드로, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.
```python
import threading

def worker(thread_id):
    local_counter = 0  # 🔹 각 스레드마다 독립적인 변수 사용
    for _ in range(100000):
        local_counter += 1
    print(f"Thread-{thread_id}: 최종 local_counter 값 = {local_counter}")

threads = [threading.Thread(target=worker, args=(i,)) for i in range(5)]

for t in threads:
    t.start()
for t in threads:
    t.join()
```


## 라이브러리를 이해하라
- 언어가 제공하는 클래스를 검토하라.

## 실행 모델을 이해하라
### 다중 스레드 프로그램에서 자주 발생하는 개념 
- 한정된 자원: 제한된 수의 자원을 뜻함. 예시. 서버에서 동시에 사용할 수 있는 DB연결, 버퍼 등 무한하지 않고 제한적이기 때문에 여러 스레드가 이 자원을 서로 나눠 써야해서 경쟁이 발생.
  비유) 식당에 자리가 10개 뿐인데, 손님은 50명. 누가 먼저 앉느냐가 문제.
  
- 상호 배체: 여러 스레드가 같은 자원을 동시에 건드리면, 문제가 생기기 때문에 한번에 하나만 접근하게 막는 개념. 예. Lock
  비유) 화장실 하나를 여러명이 쓴다면? => 한 명씩 들어가야 안전하다.

- 기아: 자원을 계속 기다리긱만 하고 얻지 못하는 상태. 항상 특정 스레드만 우선순위가 높아서 먼저 자원을 가져가면, 다른 스레드는 기다리기만 하다 굶게 된다.
  비유) 맛집 줄 서 있는데, 매번 VIP 손님이 새치기 한다. 일반 손님은 못 먹는다 -> 기아 상태

- 데드락: 스레드들이 서로가 가진 자원을 기다리면서 아무도 일을 못하게 되는 상태.
  비유) 두 사람이 서로 열쇠를 들고 교환하려는데, 서로 손을 안 놓으면 아무것도 못함.

- 라이블락: 데드락처럼 멈춰 있지 않고, 계속 바쁘게 움직이지만 일은 안되는 상황.
  비유) 복도에서 두 사람이 마주쳐서 계속 길 피해주는데… 계속 피해만 다녀서 결국 못 지나감

